
Realizing there may be many places where a system may break, often programs resort to a all-or-nothing strategy, if you are lucky, you may be notified that stuff doesn't work anymore. Try to rebuild if it doesn't work, manually resolve any issues, which all begin by being able to tell the difference in the first place. Realizing that there are possibly many parts where discrepancies may occur, programmers who have to manage different *internal* versions of weather it be program itself or affiliated core components, often have to employ a very defensive style of programming to account for the potentially many points of failure and negate some of that risk through heavy fault-tolerant routines where you are still relying on the same shady, ambiguous means of identifying these problem areas such as parts where code is relying on imported symbols, to account for and prevent any breaking due to e.g. mismatches. So what normally happens is that a program leverages a package manager solution found in the framework (e.g. programming language or operating system) they operate in, since this is often the most complicated piece of it all, and just don't bother with doing anything else. Knowing the ins-and-outs of a given framework and manually resolving the problems often is the only way a software publisher can tackle these problems which occur when software he relies on, changes.

, at a later stage, consolidated into different namespaces and published under , which had many (contrib) library functions deprecated while consolidating the namespaces / functions of mostly contributed, but also some core libraries. This provides a extra handicap for Clojure since, as a Lisp, it has relatively few programmers actively involved in the language, even less people who may blog about subjects and further, after a initial uplift in 'buzz' might face a cool-down period where less and less is published on Clojure because the people may be more familiar with it and thus sparks less interest. Since Clojure has less volume in content and people producing content, the Google search results hit extra hard (generally due to less competition over terms), giving higher relevance to possibly outdated blogs, especially when refining your searches with additional, niche, topic keywords. 



 can be troublesome even more so when you realize the need to more and more program defensively to guard yourself against the effects of those conflicting be subtle and even the most minute difference may cause a chain of events resulting in the breaking of the system. Take into consideration that it can often be hard to tell the exact difference between closely related, incompatible, versions (the case with Python2 and Python3 code) and often involves inspection of source code, looking for some recognizable difference, before one can tell for sure which version it relied on when made. It's even worse when you try to write reliable, fault-tolerant or backwards-compatible code, when your means of identification are flawed to begin with. Have a look at this [article][gnu] to see where versioning issues and decentralized configuration can all lead to. Luckily, in time, people learned and started to pay more attention to these things, applied conventions or imposed version schemes systems nd can the code be distinguished only by investigating the additional presence or absences of certain software (configuration) properties. Effectively, we are talking about program state and this happens to be *the* subject where we differ from what others do. In pedestal, occurrences of program state may, contrary to those other solutions, not be scattered throughout the project. Rather they are confined to a single object containing all the data required to manipulate the program state, among others represented in trees, abstracted in functions, protocols and macros and contained in and rendered from trees and messages flowing between components. This centralized approach also makes the application data model the most vulnerable part and as such, in pedestal, these maps are version numbered in a elaborate fashion for both your comfort and as easier detection method for fault-tolerance based parts of pedestal working with models.

(???)

, of the in the are result in breaking (partial) pieces, software
